# Lead Generation Pipeline

Проект автоматизирует поиск компаний через Yandex Search API, обогащение контактами и персонализированную рассылку писем. Вся инфраструктура ориентирована на работу в Docker.

## Структура проекта

- `app/` — исходный код служб (`main`, `scheduler`, `worker`).
- `docs/` — требования, архитектура, план внедрения.
- `Dockerfile` — базовый образ Python 3.12.
- `docker-compose.yml` — оркестрация сервисов (`app`, `scheduler`, `worker`, `db`, `redis`).
- `.env`, `.env.example` — переменные окружения (секреты не коммитим, `.env` добавлен в `.gitignore`).

## Требования

- Docker 24.0+ и docker compose plugin
- Возможность открыть исходящие соединения на `smtp.gmail.com:587` (или другой SMTP)
- Доступ к Yandex Search API и Google Sheets

## Подготовка окружения

```bash
cp .env.example .env  # заполните значения согласно комментариям
docker compose pull   # заранее загрузить базовые образы
```

После заполнения `.env` примените миграции (см. раздел «Миграции БД») и запустите compose.

## Быстрый старт в Docker Compose

```bash
docker compose up --build
```

Сервисы:
- `app` — оркестратор полного цикла (deferred → дедуп → enrichment → рассылка).
- `scheduler` — постановка deferred-запросов и polling операций.
- `worker` — enrichment контактов и отправка писем.
- `db` — PostgreSQL 16 (storage для пайплайна).
- `redis` — брокер задач/кэш.

> Redis по умолчанию доступен только внутри сети docker compose. Это позволяет запускать стек на серверах, где уже установлен системный Redis (нет конфликта портов на 6379). Если нужен доступ с хоста, создайте `docker-compose.override.yml` и добавьте в нём `ports` для сервиса `redis`, например:

```yaml
services:
  redis:
    ports:
      - "6379:6379"
```

## Как работает пайплайн

1. **Подготовка данных.** Ниши, города и страны заносятся в таблицу Google Sheets (`NICHES_INPUT`). Сервис `SheetSyncService` (CLI `python -m app.tools.sync_sheet` или автосинхронизация) превращает каждую строку в набор поисковых запросов через `QueryGenerator`: выбирается регион (`lr`), рассчитывается ночное окно и время запуска, формируется `serp_queries` с метаданными и хэшами для идемпотентности. Итоги синхронизации фиксируются в листе и таблице `search_batch_logs`.
2. **Планирование и Yandex Search.** Контейнер `scheduler` берёт pending-запросы, проверяет ночное окно и квоты, затем через `YandexDeferredClient` создаёт deferred-операции (таблица `serp_operations`). Клиент автоматически обновляет IAM токен, следит за rate-limit и при необходимости откладывает выполнение. В течение ночи `scheduler` и `app` опрашивают операции (`get_operation`), пока не получат Base64-выдачу.
3. **Парсинг SERP.** Когда операция завершена, `SerpIngestService` декодирует XML, нормализует URL/домены, фильтрует запрещённые домены и записывает документы в `serp_results`. Для каждого домена создаётся или обновляется запись в `companies` (атрибуты и таймштампы обновляются, источник помечается как `yandex_serp`).
4. **Дедупликация компаний.** `DeduplicationService` перебирает `companies`, пересчитывает `dedupe_hash` (по имени и домену), помечает первичные записи и закрывает дубликаты. Дубликатам присваивается статус `duplicate` и `opt_out=True`, чтобы исключить их из дальнейшего пайплайна.
5. **Обогащение контактов.** Воркер `worker` и оркестратор выбирают компании без контактов. `ContactEnricher` строит список страниц (`/`, `/contact`, `/about` и др.), скачивает HTML, сохраняет текстовый фрагмент главной страницы в `companies.attributes.homepage_excerpt`, извлекает только первый найденный `mailto` email, нормализует его (убирает `mailto:`, угловые скобки, пробелы) и отбрасывает варианты без `@` (телефоны, пустые строки). В БД попадает только валидный адрес.
6. **Генерация писем.** Для каждого email без рассылки оркестратор собирает `CompanyBrief` и `OfferBrief`, затем `EmailGenerator` вызывает OpenAI Chat Completions (`gpt-4.1-mini`). При отсутствии ключа или ошибке возвращается предсказуемый fallback-шаблон. Ответ парсится по JSON-схеме и возвращает пару `subject`/`body`.
8. **Доставка.** Во время рабочего окна сервис выбирает `scheduled` записи с просроченным `scheduled_for`, повторно проверяет opt-out и валидирует email (пустые строки и номера телефонов помечаются `invalid_email` и не попадают к SMTP). Для валидных адресов выбирается канал (Gmail или Яндекс), выполняется отправка и фиксируются `sent_at`, `message_id`, `metadata.route`. Повторы исключены: отбор идёт с блокировкой строк (SKIP LOCKED).
9. **Статусы компаний.** После обхода контактов компания получает `contacts_ready`. Если email не найден, записывается `contacts_not_found`, и оркестратор её больше не обрабатывает.

## Локальный запуск

1. **Подготовьте окружение:**
   ```bash
   cp .env.example .env
   # Заполните .env значениями для Yandex, Google, SMTP, OPENAI
   docker compose pull
   ```
2. **Примените миграции:**
   ```bash
   docker compose up -d db
   for f in migrations/000*.sql; do
     echo "Applying $f"
     docker compose exec -T db \
       psql -U leadgen -d leadgen -v ON_ERROR_STOP=1 -f - < "$f"
   done
   # если БД и юзер другие — подставьте свои значения
   ```
3. **Запустите сервисы:**
   ```bash
   docker compose up --build
   ```
7. **Очередь рассылки.** `EmailSender.queue` сохраняет результат генерации в `outreach_messages` со статусом `scheduled`, добавляя случайную задержку 4–8 минут относительно предыдущего письма (с блокировкой последнего `scheduled_for`, чтобы параллельные воркеры не нарушали интервал) и гарантируя, что `scheduled_for` попадает в окно 09:10–19:45 по МСК. Email и JSON-запрос LLM кладутся в `metadata`, чтобы можно было восстановить, что именно отправляется.

## Полезные команды

- Запуск синхронизации Google Sheets вручную:
  ```bash
  docker compose run --rm app python -m app.tools.sync_sheet --batch-tag <tag>
  ```
- Просмотр очереди писем:
  ```bash
  docker compose exec db psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" \
    -c "SELECT id, scheduled_for, status FROM outreach_messages ORDER BY scheduled_for LIMIT 20;"
  ```
- Перепланировать очередь с задержкой (пример интерактивного скрипта):
  ```bash
  docker compose run --rm app python - <<'PY'
  import random
  from datetime import datetime, timedelta, timezone
  from zoneinfo import ZoneInfo
  from sqlalchemy import text
  from app.modules.send_email import EmailSender
  from app.modules.utils.db import get_session_factory

  sender = EmailSender()
  tz = ZoneInfo(sender.timezone_name)
  current = datetime.now(tz)
  session = get_session_factory()()
  rows = session.execute(text("SELECT id FROM outreach_messages WHERE status='scheduled' ORDER BY created_at"))
  for row in rows.mappings():
      current += timedelta(seconds=random.randint(240, 480))
      session.execute(text("UPDATE outreach_messages SET scheduled_for = :ts WHERE id = :id"),
                      {"ts": current.astimezone(timezone.utc), "id": row["id"]})
  session.commit()
  PY
  ```
- Переотправка письма вручную:
  ```bash
  docker compose run --rm app python - <<'PY'
  from app.modules.send_email import EmailSender
  sender = EmailSender()
  sender.deliver(
      outreach_id="<uuid>",
      company_id="<company uuid>",
      contact_id="<contact uuid>",
      to_email="test@example.com",
      subject="Тест",
      body="Тестовое письмо"
  )
  PY
  ```
- Очистка очереди от невалидных адресов (телефоны, пустые строки). Скрипт помечает такие письма как `skipped` и удаляет «email»-контакты без `@`:
  ```bash
  docker compose exec db psql -U "$POSTGRES_USER" -d "$POSTGRES_DB" \
    -f docs/sql/cleanup-invalid-emails.sql
  ```

### Чек-лист ручной проверки MX-роутинга

1. Подготовьте по одному адресу с MX Яндекса (`@yandex.ru`), Mail.ru (`@mail.ru`) и Google (`@gmail.com`), а также адрес с намеренно несуществующим доменом.
2. В очереди (`outreach_messages`) выставьте `scheduled_for` в текущий час и запустите `EmailSender.deliver` (см. команды выше).
3. Убедитесь, что письма на Яндекс/Мейл.ру ушли через Яндекс SMTP (`metadata.route.provider = "yandex"`, заголовок `From` совпадает с `YANDEX_FROM`, `Reply-To` отсутствует — ответы пойдут в этот же ящик).
4. Проверьте, что письма на остальные домены и адрес с ошибкой DNS отправлены через Gmail с `metadata.mx.class = "OTHER"`/`"UNKNOWN"`.
5. Протестируйте случай с неверным паролем приложения Яндекса: временно измените `YANDEX_PASS`, перезапустите доставку и убедитесь, что письмо не отправилось (статус `failed`, `metadata.route.error` содержит ответ SMTP).

## Деплой на удалённом сервере через Git

1. **Подготовка сервера:** установите Docker и docker compose plugin, создайте отдельного пользователя без root.
2. **Клонируйте репозиторий:**
   ```bash
   git clone https://github.com/kodjooo/lead-generation.git
   cd lead-generation
   cp .env.example .env
   ```
3. **Заполните `.env`:** пропишите ключи Yandex и Google, Gmail `GMAIL_*` (App Password) и Яндекс `YANDEX_*` параметры, активируйте `ROUTING_ENABLED=true`, установите `EMAIL_SENDING_ENABLED=true`.
4. **Разместите ключи сервисных аккаунтов:** скопируйте файлы JSON в каталог `secure/` на сервере. Если файла нет (`secure/authorized_key.json`), Docker создаст директорию с таким именем, и сервисы завершатся ошибкой `IsADirectoryError`.
5. **Примените миграции:**
   ```bash
   docker compose up -d db
   for f in migrations/000*.sql; do
     echo "Applying $f"
     docker compose exec -T db \
       psql -U leadgen -d leadgen -v ON_ERROR_STOP=1 -f - < "$f"
   done
   # замените leadgen/leadgen на свои POSTGRES_USER/POSTGRES_DB при необходимости
   ```
   
6. **Запустите сервисы:**
   ```bash
   docker compose up -d --build
   ```
   Хостовой Redis останавливать не нужно: контейнерный Redis работает только внутри сети compose и не занимает порт `6379` на сервере.
7. **Обновление:**
   ```bash
   git pull
   docker compose up -d --build
   ```
   Если есть новые миграции — повторите шаг 4.
8. **Мониторинг:**
   ```bash
   docker compose logs -f app
   docker compose logs -f worker
   ```

### Управление оркестратором

Запустить оркестратор однократно:

```bash
docker compose run --rm app --mode once
```

Фоновый режим по умолчанию (`loop`) запускается в контейнерах `app`, `scheduler`, `worker` при `docker compose up`.

## Переменные окружения

### Yandex Cloud

- `YANDEX_CLOUD_FOLDER_ID` — ID каталога (консоль YC → «Обзор»).
- `YANDEX_CLOUD_IAM_TOKEN` — можно оставить пустым; при наличии ключа сервисного аккаунта пайплайн возьмёт токен автоматически.
- `YANDEX_CLOUD_SA_KEY_FILE` / `YANDEX_CLOUD_SA_KEY_JSON` — путь или содержимое ключа сервисного аккаунта. Получить ключ:

  ```bash
  yc iam key create --service-account-name <sa_name> --output key.json
  ```

  Ключ храните в Secret Manager или CI и не коммитьте в репозиторий.
- `YANDEX_ENFORCE_NIGHT_WINDOW` — если `true`, отправка запросов выполняется только в ночное окно; установите `false` для дневных тестов.

### Google Sheets

- `GOOGLE_SHEET_ID` — идентификатор таблицы с листом `NICHES_INPUT` (из URL вида `https://docs.google.com/spreadsheets/d/<ID>/...`).
- `GOOGLE_SHEET_TAB` — имя вкладки (по умолчанию `NICHES_INPUT`).
- `GOOGLE_SA_KEY_FILE` / `GOOGLE_SA_KEY_JSON` — ключ сервисного аккаунта Google с доступом на чтение/редактирование таблицы.
- `SHEET_SYNC_ENABLED` — включает автоматическую синхронизацию (true/false).
- `SHEET_SYNC_INTERVAL_MINUTES` — период автосинхронизации (мин., по умолчанию 60).
- `SHEET_SYNC_BATCH_TAG` — опциональный фильтр по партии.

### Email и OpenAI

- `ROUTING_ENABLED`, `ROUTING_MX_CACHE_TTL_HOURS`, `ROUTING_DNS_TIMEOUT_MS`, `ROUTING_DNS_RESOLVERS`, `ROUTING_RU_MX_PATTERNS`, `ROUTING_RU_MX_TLDS`, `ROUTING_FORCE_RU_DOMAINS` — параметры MX-маршрутизации (см. `docs/requirements-RU-Yandex-otherwise-Gmail.md`). Список паттернов можно пересобрать скриптом:
  ```bash
  docker compose run --rm app python scripts/discover_ru_mx.py
  ```
- `GMAIL_SMTP_HOST`, `GMAIL_SMTP_PORT`, `GMAIL_SMTP_TLS`, `GMAIL_USER`, `GMAIL_PASS`, `GMAIL_FROM` — отправка через Gmail (App Password из Google Account → Security → App Passwords).
- `YANDEX_SMTP_HOST`, `YANDEX_SMTP_PORT`, `YANDEX_SMTP_SSL`, `YANDEX_USER`, `YANDEX_PASS`, `YANDEX_FROM` — отправка через личный аккаунт Яндекс (пароль приложения в mail.yandex.ru → Настройки → Пароли приложений). Если канал не используется, оставьте значения пустыми.
- `EMAIL_SENDING_ENABLED` — если `false`, письма только сохраняются в `outreach_messages` со статусом `scheduled`, реальная отправка отключена.
- `OPENAI_API_KEY` — ключ OpenAI для генерации персонализированных писем.

## Синхронизация запросов из Google Sheets

1. Заполните таблицу на листе `NICHES_INPUT` (столбцы `niche`, `city`, `country`, `batch_tag`).
2. Выполните синхронизацию:

   ```bash
   docker compose run --rm app python -m app.tools.sync_sheet
   # или выбрать конкретную партию
   docker compose run --rm app python -m app.tools.sync_sheet --batch-tag batch-2025-10
   ```

   Скрипт создаст записи в `serp_queries` и обновит служебные колонки листа (`status`, `generated_count` и т.д.).

3. При установке `SHEET_SYNC_ENABLED=true` оркестратор автоматически вызывает синхронизацию каждые `SHEET_SYNC_INTERVAL_MINUTES` минут, используя тот же CLI-процесс под капотом.

## Миграции БД

После обновления проекта выполните SQL-миграции:

```bash
for f in migrations/000*.sql; do
  echo "Applying $f"
  docker compose exec -T db \
    psql -U leadgen -d leadgen -v ON_ERROR_STOP=1 -f - < "$f"
done
# если переменные отличаются, замените leadgen/leadgen на свои POSTGRES_USER/DB
```

## Развёртывание на удалённом сервере

См. раздел «Деплой на удалённом сервере через Git» выше — там перечислены все шаги (клонирование репозитория, заполнение `.env`, миграции и запуск). Дополнительно рекомендуется настроить:

- автоматический старт с помощью systemd unit, если сервер перезагружается;
- регулярные бэкапы каталога `pg_data` и файла `.env`;
- централизованный сбор логов (`docker compose logs`, Loki, ELK и т.д.).

## Тестирование

```bash
docker compose run --rm app python -m pytest
```
4. **Проверка рассылки:** убедитесь, что `EMAIL_SENDING_ENABLED=true`, а текущее время попадает в окно 09:10–19:45 (МСК). Для ручного теста можно изменить `scheduled_for` конкретной записи; учитывайте, что новые письма автоматически разнесены на 4–8 минут от предыдущего.
