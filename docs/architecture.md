## Этап 1. Анализ требований

### Цели системы
- Автономно находить до 5000 уникальных компаний в месяц по тематике и региону.
- Собрать контакты и подготовить персонализированные письма с бизнес-выгодой.
- Отправлять до 100 писем в сутки (первоначально через Gmail SMTP) с учётом opt-out.
- Обеспечить отслеживание статусов всех сущностей и идемпотентность операций.

### Критичные ограничения
- Используем только официальный Yandex Search API в режиме ночных deferred-запросов.
- Строгая дедупликация по домену/названию до обогащения и рассылки.
- Любой шаг пайплайна должен быть перезапускаемым без дублирования данных.
- Соблюдение юридических требований (GDPR, 152‑ФЗ) и уважение opt-out.

### Высокоуровневый пайплайн
1. **Планировщик night-only** — формирует очередь deferred-запросов (00:00–07:59 MSK) и следит за квотами.
2. **Yandex Deferred Client** — создаёт операции поиска, опрашивает статусы, извлекает Base64-ответы.
3. **Нормализация SERP** — парсит XML, нормализует URL/домены, сохраняет результаты в БД.
4. **Дедупликация компаний** — аггрегирует результаты, устраняет дубликаты и спорные записи.
5. **Обогащение контактов** — скачивает страницы, извлекает контакты, фильтрует нежелательные адреса.
6. **Генерация писем** — формирует персонализированные шаблоны на основе профиля компании и оффера.
7. **Отправка и трекинг** — отправляет письма, пишет статусы, реагирует на отказ/ошибки.
8. **Аналитика и экспорт** — формирует отчёты, выгрузки CSV и журналы пайплайна.

### Ключевые сущности
- `serp_queries` — исходные запросы к API с параметрами (регион, тематика, хэши).
- `serp_operations` — идентификаторы Yandex deferred операций и их статусы.
- `serp_results` — нормализованные результаты (URL, домен, заголовок, позиция).
- `companies` — уникальные компании с атрибутами (название, домен, регионы).
- `contacts` — найденные e-mail, телефоны, страницы контактов.
- `outreach_messages` — сгенерированные письма, статус отправки, канал.
- `opt_out_registry` — база отказов и юридических ограничений.

### Базовый технологический стек (предварительный)
- Язык: Python 3.11+.
- БД: PostgreSQL (основное), SQLite (локальные тесты).
- Очереди: Redis + Celery (вариант) или APScheduler для планировщика.
- Логи: структурированный JSON (Loguru/стандартный logging).
- Контейнеризация: Docker + docker-compose (обязательно).
- Тестирование: pytest + responses/HTTPretty для мока API.

### Метрики успеха
- Доля уникальных компаний: ≥ 5000/мес.
- Доля писем с положительным статусом отправки: ≥ 95%.
- Процент повторных доменов в контакт-листе: ≤ 0.5%.
- SLA по обработке deferred-операции: ≤ 12 часов с момента постановки в очередь.

## Этап 2. Docker-инфраструктура

### Сервисы docker-compose
- `app` — основной сервис оркестрации; использует общий код в каталоге `app/`, подключён в режиме live-reload через volume.
- `scheduler` — отдельный контейнер для планировщика ночных задач; будет запускать отложенные операции и cron-триггеры.
- `worker` — контейнер для фоновых обработчиков (очереди дедупликации, обогащения, рассылки).
- `db` — PostgreSQL 16 (persistent volume `pg_data`), содержит все сущности пайплайна.
- `redis` — брокер задач/кэш для очередей и rate-limit логики (volume `redis_data` для снапшотов).

Все сервисы собираются из общего Dockerfile (Python 3.12 slim) и используют переменные окружения из `.env`.

### Сетевое и хранилище
- Внутренняя сеть docker-compose используется по умолчанию; доступ к БД внутри стека через хост `db`.
- Данные PostgreSQL и Redis сохраняются на хосте в `pg_data` и `redis_data` для персистентности.
- Порты 5432 и 6379 проброшены наружу через переменные окружения для диагностики и интеграций.

### Управление конфигурацией
- `.env` содержит рабочие значения с комментариями, где брать доступы (IAM токен, SMTP, OpenAI, БД).
- `.env.example` повторяет структуру с placeholder-значениями и служит шаблоном для команд.
- `.gitignore` блокирует попадание `.env` в коммиты; `.dockerignore` исключает файл из образов.

### Особенности запуска
- Для предварительных заглушек службы `app`, `scheduler`, `worker` запускаются в режим ожидания и пишут журнал готовности.
- Политика `restart: unless-stopped` обеспечивает автоматическое восстановление после сбоев или перезагрузки хоста.
- Healthcheck настроен для PostgreSQL (`pg_isready`) и Redis (`redis-cli ping`) — это гарантирует корректную последовательность запуска зависимых сервисов.

## Этап 3. База данных и миграции

### Схема данных
- `serp_queries` — очередь поисковых запросов; содержит параметры запуска, хэш idempotency и статус.
- `serp_operations` — асинхронные операции Yandex Search (состояния, ретраи, raw payload).
- `serp_results` — нормализованные результаты SERP с позициями, доменами и признаками обработки.
- `companies` — агрегированная сущность компании, dedupe-hash, ссылки на первоисточники, атрибуты.
- `contacts` — найденные контактные точки (email/phone), качество, источник, временные метки.
- `outreach_messages` — письма для отправки с каналом, статусом, ошибками доставки.
- `opt_out_registry` — реестр отказов, хранит причину и источник запрета.
- `processing_jobs` — таблица внутренних задач (воркеры/очереди) с приоритетами и окном исполнения.

Все ключевые таблицы используют UUID по умолчанию (`gen_random_uuid`) и хранят `created_at/updated_at`.

### Миграции
- `migrations/0001_init.sql` создаёт основные сущности, индексы и idempotent-ограничения.
- Таблица `schema_migrations` поддерживает историю применённых миграций (управляется на уровне утилиты).
- Скрипты миграций находятся в каталоге `migrations/` и применяются строго в порядке имени файла.

### Работа с БД
- `app/config.py` описывает настройки (БД, SMTP, Redis, API) и кэширует их для сервисов.
- `app/modules/utils/db.py` создаёт SQLAlchemy Engine, фабрику сессий, даёт контекст `session_scope`.
- `run_sql_migrations` применяет SQL-файлы и гарантирует идемпотентность через `schema_migrations`.
- Тестовые фикстуры (`tests/fixtures`) содержат seed-данные для будущих модулей.

### Ограничения и правила
- Все операции обязаны выполняться в транзакциях; при ошибках транзакции откатываются.
- Дедупликация доменов обеспечивается уникальными индексами (`dedupe_hash`, `canonical_domain`).
- Контакты и opt-out используют регистронезависимые уникальные индексы (через `LOWER(value)`).

## Этап 4. Модуль Yandex Deferred Search

### Клиент и интеграция
- `app/modules/yandex_deferred.py` реализует клиента Yandex Search API (create + poll + decode).
- Конфигурация: IAM токен, folder_id, таймауты, ночное окно `00:00–07:59` (по `APP_TIMEZONE`), квоты 10 rps / 600 rpm / 35k rph.
- `DeferredQueryParams` описывает тело запроса; `OperationResponse` предоставляет decode Base64 XML.
- Планировщик (`app/scheduler.py`) инициализирует клиента через `get_settings()` и готов к расширению обработкой очередей.

### Управление квотами и надёжность
- Rate-limit реализован через sliding window (deque) с configurable правилами для создания и опроса операций.
- Все запросы логируются (debug-уровень), ошибки выбрасывают `YandexAPIError` с деталями ответа.
- Поддерживается ожидание завершения операций с таймаутом и настраиваемым интервалом опроса.
- Нарушение ночного окна (`NightWindowViolation`) перехватывается планировщиком и сигнализирует о необходимости отложить задачу.

### Тестирование
- `tests/test_yandex_deferred.py` покрывает создание deferred-запросов, ожидание завершения, декодирование Base64 и отлов ошибок.
- Используется `respx` для мокирования HTTP-вызовов и `FakeClock` для детерминированного контроля времени и задержек.

## Этап 5. Обработка SERP и нормализация

### Парсинг и нормализация
- `app/modules/serp_ingest.py` парсит XML, извлекает `<doc>` группы и формирует `SerpDocument`.
- `app/modules/utils/normalize.py` отвечает за каноникализацию URL/доменов, построение dedupe-hash и очистку сниппетов.
- Сниппеты очищаются от лишних пробелов, URL приводятся к https-схеме и без фрагментов.

### Сохранение в БД
- `SerpIngestService` сохраняет результаты в `serp_results` (upsert по `(operation_id, url)`), сохраняет язык и метаданные (`{"source": "yandex"}`).
- Для каждой записи создаётся/обновляется компания в `companies` по `dedupe_hash` (на основе домена), обновляется `website_url` и атрибуты.
- Все операции выполняются в транзакциях через `session_scope`; при конфликте данные обновляются.

### Обработка ошибок
- Пустые или некорректные XML отвечают `SerpParseError`; документы без валидного URL пропускаются.
- Логгер `app.serp_ingest` фиксирует пропуски и пустые результаты.

### Тестирование
- `tests/test_normalize.py` проверяет нормализацию URL, доменов, dedupe-хешей и очистку сниппетов.
- `tests/test_serp_ingest.py` валидирует парсинг XML и корректность вызовов upsert c заглушечной сессией.

## Этап 6. Дедупликация и управление сущностями

### Логика дедупликации
- `app/modules/deduplicate.py` подсчитывает dedupe-хэши, группирует компании по домену и помечает дубликаты.
- Первичные компании сохраняют статус (если был `duplicate` → возвращаем `new`), дубликаты отмечаются `duplicate` и `opt_out = TRUE`.
- Обновляется `canonical_domain` и dedupe-hash для всех компаний (domain priority: canonical → website → name).

### Используемые правила
- Домены нормализуются через `normalize_domain`, хэш строится устойчиво (SHA1 по домену).
- При конфликте доменов выбирается первая компания по `created_at`.
- Дубликаты исключаются из дальнейшей рассылки за счёт `opt_out`.

### Тесты
- `tests/test_deduplicate.py` эмулирует базу в памяти: проверяет пересчёт хэшей, пометку дубликатов, сохранение первичных компаний.

## Этап 7. Обогащение контактов

### Процесс
- `app/modules/enrich_contacts.py` находит контактные страницы (`/contact`, `/contacts`, `/about`, `/контакты`) и собирает e-mail/телефоны.
- Используется `httpx` для загрузки страниц и `BeautifulSoup`+regex для извлечения `mailto`, `tel`, а также текста.
- Контакты нормализуются (нижний регистр для email, цифры для телефонов) и сохраняются в `contacts` c idempotent `ON CONFLICT`.

### Сохранение и приоритезация
- Первый найденный email/телефон помечается `is_primary=True`.
- Качество контакта определяется источником: `mailto` → 1.0, `tel` → 0.9, текстовые находки → 0.8/0.6.
- При конфликте обновляются `quality_score`, `last_seen_at`, атрибуты объединяются через `jsonb` merge.

### Тесты
- `tests/test_enrich_contacts.py` проверяет извлечение контактов из HTML и корректность сохранения через заглушечную сессию.

## Этап 8. Генерация и отправка писем

### Генерация
- `app/modules/generate_email_gpt.py` формирует контекст по компании и предложению, обращается к OpenAI Chat Completions (JSON schema), есть fallback-шаблон.
- Поддерживаются `CompanyBrief`, `OfferBrief`, `ContactBrief`; ответы приводятся к `EmailTemplate`.
- При ошибках API или отсутствии ключа используется deterministic fallback.

### Отправка
- `app/modules/send_email.py` отправляет письма через SMTP (`starttls`), использует `EmailSender`.
- Перед отправкой проверяется `opt_out_registry`; дубликаты помечаются статусом `skipped`.
- Статус сохраняется в `outreach_messages` (`sent`, `failed`, `skipped`), с `last_error`, `metadata`, `sent_at`.

### Тесты
- `tests/test_email_modules.py` мокает OpenAI и SMTP, проверяет fallback, отправку, обработку opt-out и сохранение статусов.

## Этап 9. Оркестрация и планировщик

### Оркестратор
- `app/orchestrator.py` объединяет pipeline: постановка deferred-запросов, polling операций, серп-инжест, дедуп, enrichment, рассылка.
- Конфиг `OrchestratorConfig` задаёт batch size и интервал цикла, методы доступны публично (`schedule_deferred_queries`, `poll_operations`, `enrich_missing_contacts`, `generate_and_send_emails`).
- В оркестраторе используются все модули: `YandexDeferredClient`, `SerpIngestService`, `DeduplicationService`, `ContactEnricher`, `EmailGenerator`, `EmailSender`.

### Службы Docker
- `app/main.py` запускает оркестратор в режиме `once` или `loop` (CLI аргументы).
- `app/scheduler.py` создаёт deferred-запросы в ночное окно и опрашивает операции.
- `app/worker.py` отвечает за enrichment контактов и рассылку, работает циклически.

### Логирование
- Все сервисы используют `logging` (INFO+DEBUG) и фиксируют результаты каждого цикла.
- Ошибки при вызове API/SMTP логируются и сохраняются в `outreach_messages`.

## Этап 10. Финальное тестирование и документация

- Все юнит-тесты запускаются командой `python -m pytest` (20 тестов, покрытие ключевых модулей).
- README дополнен инструкциями по работе оркестратора, развёртыванию и тестам.
- `docs/plan.md` и `docs/architecture.md` зафиксированы по каждому этапу; `.env` и `.env.example` актуализированы.

## Этап 11. Автоматизация IAM токена

### Авторизация Yandex Cloud
- Добавлен модуль `app/modules/utils/iam.py`, который генерирует JWT на основе ключа сервисного аккаунта и автоматически обновляет IAM токен (кэш с запасом 60 секунд).
- Поддерживаются переменные `YANDEX_CLOUD_SA_KEY_FILE` / `YANDEX_CLOUD_SA_KEY_JSON`; при их наличии токен берётся автоматически. `YANDEX_CLOUD_IAM_TOKEN` остался как статический fallback.
- `PipelineOrchestrator` использует провайдера токенов и пробрасывает `token_provider` в `YandexDeferredClient`, что убрало ручное обновление токенов.

### Изменения клиента Yandex
- `YandexDeferredClient` теперь принимает `token_provider`, вызывает его перед каждым запросом и выбрасывает исключение при отсутствии токена.
- Добавлены тесты на использование провайдера и на сам генератор IAM токенов (`tests/test_iam_provider.py`, `tests/test_yandex_deferred.py`).
